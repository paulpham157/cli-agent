name: Build and Release CLI Agent

on:
  workflow_call:
    inputs:
      deploy:
        type: boolean
        required: true
        default: false
    secrets:
      access_token:
        required: true
      pypi_test_token:
        required: false
      pypi_token:
        required: false
      ssh_private_key:
        required: true
      credentials_json:
        required: false
      apple_app_specific_password:
        required: false
      fastlane_password:
        required: false
      match_password:
        required: false
      chocolatey_api_key:
        required: false

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ macos-14-large, macos-latest, windows-latest ]
        include:
          - os: macos-14-large
            zipFileName: pieces-cli-mac_x86_64
          - os: macos-latest
            zipFileName: pieces-cli-mac_arm64
          - os: windows-latest
            zipFileName: pieces-cli-win_x86_64
    steps:
      ### Checking out our Repo
      - uses: actions/checkout@v3

      ### Setting up python
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: 3.11

      ### Getting the version from the git tag or the branch name if there is none
      - name: Get the version
        shell: bash
        id: get_version
        run: echo "VERSION=$(echo $GITHUB_REF | cut -d / -f 3)" >> $GITHUB_OUTPUT

      ### Generating our staging version number if we are not production
      - name: Get staging version
        shell: bash
        id: staging_version
        run: echo "STAGING_VERSION=$(/bin/bash staging_versioning.sh)" >> $GITHUB_OUTPUT
        if: inputs.deploy == false

      ### Install SSH
      - uses: shimataro/ssh-key-action@v2
        with:
          key: "${{ secrets.ssh_private_key }}"
          name: id_rsa
          known_hosts: "github.com"
          if_key_exists: fail

      ### Setting up our fastlane certificates
      - name: Setup Certificates
        run: |-
          cd macos
          bundle install
          bundle exec fastlane setup
        env:
          MATCH_PASSWORD: ${{ secrets.match_password }}
          FASTLANE_PASSWORD: ${{ secrets.fastlane_password }}
        if: runner.os != 'Windows'

      ### Installing our dependencies
      - name: Install dependencies
        run: |
          pip install poetry -U
          poetry install 

      ### Setting the version in the pyproject.toml for unix builds
      - name: Set Version Shell Script (Unix)
        if: runner.os != 'Windows'
        run: |
          if [[ ${{ steps.get_version.outputs.VERSION }} =~ [0-9]+.[0-9]+.[0-9]+$ ]]; then
            echo "This is a tagged build"
            RELEASE_VERSION='${{ steps.get_version.outputs.VERSION }}'
            RELEASE_VERSION="${RELEASE_VERSION#v}"
            poetry version $RELEASE_VERSION
            sed -i "" "s/__version__ = .*/__version__ = '${RELEASE_VERSION}'/" src/pieces/__init__.py
          else
            echo "This is not a tagged build"
            STAGING_VERSION='${{ steps.staging_version.outputs.STAGING_VERSION }}'
            poetry version $STAGING_VERSION
            sed -i "" "s/__version__ = .*/__version__ = '${STAGING_VERSION}'/" src/pieces/__init__.py
          fi
        shell: bash

      ### Setting the version in the pyproject.toml for Windows builds
      - name: Set Version PowerShell Script (Windows)
        if: runner.os == 'Windows'
        run: |
          if ("${{ steps.get_version.outputs.VERSION }}" -match "^\d+\.\d+\.\d+$") {
            Write-Output "This is a tagged build"
            $RELEASE_VERSION = "${{ steps.get_version.outputs.VERSION }}".TrimStart("v")
            poetry version $RELEASE_VERSION
            (Get-Content src\pieces\__init__.py) -replace '__version__ = .+', "__version__ = '$RELEASE_VERSION'" | Set-Content src\pieces\__init__.py
          }
          else {
            Write-Output "This is not a tagged build"
            $STAGING_VERSION = "${{ steps.staging_version.outputs.STAGING_VERSION }}"
            poetry version $STAGING_VERSION
            (Get-Content src\pieces\__init__.py) -replace '__version__ = .+', "__version__ = '$STAGING_VERSION'" | Set-Content src\pieces\__init__.py
          }
        shell: pwsh

      ### Writing our staging version to a file to be pulled in the last step to update our json in the cloud
      - name: Write staging version to file
        shell: bash
        run: echo "${{ steps.staging_version.outputs.STAGING_VERSION }}" > staging_version$GITHUB_RUN_NUMBER.txt
        if: ${{ inputs.deploy == false && inputs.beta == false }}

      ### Building the Library and Wheel files
      - name: Build library
        run: poetry build

      - name: Get virtual environment site-packages path
        if: runner.os == 'Windows'
        id: venv_path
        run: |
          Invoke-Expression (poetry env activate)
          $sitePackagesPath = (python -c "import site; print(site.getsitepackages()[0])").Trim()
          Write-Host "Site-packages path: $sitePackagesPath"
          echo "VENV_SITE_PACKAGES_PATH=$sitePackagesPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: powershell

      ### Build stand-alone step for macOS (keeping codesigning)
      - name: Build stand alone (macOS)
        if: runner.os != 'Windows'
        run: |
          poetry run pyinstaller -c --onefile src/pieces/app.py --hidden-import=pydantic_core --name=pieces --codesign-identity="Developer ID Application: Mesh Intelligent Technologies, Inc. (287L9TU9JL)"

      ### Build stand-alone step for Windows (build .exe)
      - name: Build stand alone (Windows)
        if: runner.os == 'Windows'
        run: |
          Invoke-Expression (poetry env activate)
           pyinstaller -c --onefile src/pieces/app.py `
              --name=pieces `
              --hidden-import="pieces.pieces_argparser" `
              --paths="${{ steps.venv_path.outputs.VENV_SITE_PACKAGES_PATH }}" `
              --codesign-identity="Developer ID Application: Mesh Intelligent Technologies, Inc. (287L9TU9JL)" `
              --python-option="W ignore" # Ignore all warnings 
        shell: powershell



      ### Package binary to zip file for macOS
      - name: Mac Binary to Zip File
        if: runner.os != 'Windows'
        run: |
          if [[ ${{ steps.get_version.outputs.VERSION }} =~ [0-9]+.[0-9]+.[0-9]+$ ]]; then
              ditto -c -k --sequesterRsrc "dist/pieces" dist/${{ matrix.zipFileName }}-${{ steps.get_version.outputs.VERSION }}.zip
          else
              ditto -c -k --sequesterRsrc "dist/pieces" dist/${{ matrix.zipFileName }}-${{ steps.staging_version.outputs.STAGING_VERSION }}.zip
          fi

      ### Submission to apple notary
      # - name: Submit Zip to apple notary
      #   if: runner.os != 'Windows'
      #   run: |
      #     if [[ ${{ steps.get_version.outputs.VERSION }} =~ [0-9]+.[0-9]+.[0-9]+$ ]]
      #     then
      #         xcrun notarytool submit dist/${{ matrix.zipFileName }}-${{ steps.get_version.outputs.VERSION }}.zip --password ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }} --apple-id "development@pieces.app" --team-id "287L9TU9JL" --wait
      #     else
      #         xcrun notarytool submit dist/${{ matrix.zipFileName }}-${{ steps.staging_version.outputs.STAGING_VERSION }}.zip --password ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }} --apple-id "development@pieces.app" --team-id "287L9TU9JL" --wait
      #     fi

      ### Package binary to zip file for Windows using PowerShell
      - name: Windows Binary to Zip File
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          if ("${{ steps.get_version.outputs.VERSION }}" -match "^\d+\.\d+\.\d+$") {
            Compress-Archive -Path ".\dist\pieces.exe" -DestinationPath ".\dist\${{ matrix.zipFileName }}-${{ steps.get_version.outputs.VERSION }}.zip"
          }
          else {
            Compress-Archive -Path ".\dist\pieces.exe" -DestinationPath ".\dist\${{ matrix.zipFileName }}-${{ steps.staging_version.outputs.STAGING_VERSION }}.zip"
          }

      ### Upload to github artifacts
      - uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}
          path: dist/*

      ### Uploading our staging version text file to be pulled down later
      - uses: actions/upload-artifact@v4
        with:
          name: staging_version-${{ matrix.os }}
          path: "*.txt"
        if: inputs.deploy == false

      - name: Test Windows Executable Basic Commands
        if: runner.os == 'Windows'
        run: |
          Get-ChildItem src/pieces
          Set-Location dist 
          Write-Host "--- Testing 'pieces.exe --version' command ---"
          try {
              # Run the --version command and capture its output
              # 2>&1 redirects stderr to stdout, so we capture all messages.
              $versionOutput = (.\pieces.exe --version 2>&1)
              Write-Host "Output for --version:`n$versionOutput"

              # Check if the command executed successfully (exit code 0)
              # In PowerShell, a non-zero exit code usually throws an error if $ErrorActionPreference is 'Stop'.
              # If it didn't throw, it likely succeeded.
              Write-Host "SUCCESS: 'pieces.exe --version' executed without error."
          } catch {
              Write-Error "FAILURE: 'pieces.exe --version' threw an error: $($_.Exception.Message)"
              exit 1 # Fail the step if an error occurred
          }

          Write-Host "Basic executable functionality tests passed."
        shell: powershell

  ### Pushing the built packages to GCP and GitHub
  push-build:
    runs-on: ubuntu-latest
    needs:
      - build
    steps:

      ### Pulling down the previously built plugins
      - uses: actions/download-artifact@v4

      ### What is in here??
      - name: List
        run: ls -la

      ### Authenticating with gcloud
      - name: Authenticate with Google cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.credentials_json }}
          project_id: ${{ inputs.project_id }}
          create_credentials_file: true

      ### Setting up gcloud cli
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      ### Verifying that we are good to go with gcloud
      - name: 'Use gcloud CLI'
        run: 'gcloud info'

      ### Getting either the git tag or branch name to be set in the json
      - name: Get the version
        id: get_version
        run: echo "VERSION=$(echo $GITHUB_REF | cut -d / -f 3)" >> $GITHUB_OUTPUT

      ### Installing some machine deps
      - name: Install Dependencies
        run: sudo apt-get install jq -y

      ### This big, long if statement handles pushing the builds to the correct location, as well as setting the proper
      ### build info for the json files read by the server
      - name: Upload Artifacts
        run: |
          GITHUB_RUN_NUMBER+="gha"
          if [[ ${{ steps.get_version.outputs.VERSION }} =~ [0-9]+.[0-9]+.[0-9]+ ]]; then
              echo "Git Tag Versioning"
              export CHANNEL=production
              export VERSION=${{ steps.get_version.outputs.VERSION }}
              export BUCKET=app-releases-production
              export production_json="$(curl https://storage.googleapis.com/app-releases-production/pieces_cli/production/latest.json -H "Accept: application/json")"
              export reversed_production_json=$(echo $production_json | jq 'reverse')
              export updated_production_json=$(echo $reversed_production_json | jq --arg number "$GITHUB_RUN_NUMBER" --arg channel "$CHANNEL" --arg branch "${{ steps.get_version.outputs.VERSION }}" --arg tag "$VERSION" --arg sha1 "${{ github.sha }}" '.[length] |= . + {channel: $channel, number: $number, branch: $branch, tag: $tag, sha1: $sha1}')
              echo $updated_production_json | jq 'reverse' > latest.json
              jq -n --arg number "$GITHUB_RUN_NUMBER" --arg channel "$CHANNEL" --arg branch "${{ steps.get_version.outputs.VERSION }}" --arg tag "$VERSION" --arg sha1 "${{ github.sha }}" '{channel: $channel, number: $number, branch: $branch, tag: $tag, sha1: $sha1}' > latest-single.json
          else
              echo "Staging Versioning"
              export CHANNEL=staging
              export VERSION=$(echo "$(set -- */*.txt; echo "$1")" | xargs head -n 1)
              export BUCKET=app-releases-staging
              export staging_json="$(curl https://storage.googleapis.com/app-releases-staging/pieces_cli/staging/latest.json -H "Accept: application/json")"
              export reversed_staging_json=$(echo $staging_json | jq 'reverse')
              export updated_staging_json=$(echo $reversed_staging_json | jq --arg number "$GITHUB_RUN_NUMBER" --arg channel "$CHANNEL" --arg branch "${{ steps.get_version.outputs.VERSION }}" --arg tag "$VERSION" --arg sha1 "${{ github.sha }}" '.[length] |= . + {channel: $channel, number: $number, branch: $branch, tag: $tag, sha1: $sha1}')
              echo $updated_staging_json | jq 'reverse' > latest.json
              jq -n --arg number "$GITHUB_RUN_NUMBER" --arg channel "$CHANNEL" --arg branch "${{ steps.get_version.outputs.VERSION }}" --arg tag "$VERSION" --arg sha1 "${{ github.sha }}" '{channel: $channel, number: $number, branch: $branch, tag: $tag, sha1: $sha1}' > latest-single.json
          fi
          gsutil -h "Cache-Control: max-age=0" cp */**.tar.gz gs://$BUCKET/pieces_cli/$GITHUB_RUN_NUMBER/pieces.tar.gz
          gsutil -h "Cache-Control: max-age=0" cp */**.whl gs://$BUCKET/pieces_cli/$GITHUB_RUN_NUMBER/pieces.tar.gz.whl
          gsutil -h "Cache-Control: max-age=0" cp latest-single.json gs://$BUCKET/pieces_cli/$CHANNEL/latest-single.json
          gsutil -h "Cache-Control: max-age=0" cp latest.json gs://$BUCKET/pieces_cli/$CHANNEL/latest.json
          gsutil cp -r */**.tar.gz gs://$BUCKET/pieces_cli/release/
          gsutil cp -r */**.zip gs://$BUCKET/pieces_cli/release/
          gsutil cp -r */**.whl gs://$BUCKET/pieces_cli/release/
          echo "releasetag=$VERSION" >> $GITHUB_ENV

      ### Upload to GitHub releases pre-release
      - name: Release to GitHub Releases
        uses: softprops/action-gh-release@v2
        if: inputs.deploy == false
        with:
          files: |
            macos-latest/*.tar.gz
            macos-latest/*.whl
            */**.zip
          fail_on_unmatched_files: false
          name: ${{ env.releasetag }}
          tag_name: ${{ env.releasetag }}
          generate_release_notes: true
          prerelease: true

      ### Upload to GitHub releases
      - name: Release to GitHub Releases
        uses: softprops/action-gh-release@v2
        if: inputs.deploy == true
        with:
          files: |
            macos-latest/*.tar.gz
            macos-latest/*.whl
            */**.zip
          fail_on_unmatched_files: false
          name: ${{ env.releasetag }}
          tag_name: ${{ env.releasetag }}
          generate_release_notes: true
          prerelease: false

      ### Upload to test Pypi
      - name: Upload Packages to PyPi for release
        if: inputs.deploy == true
        run: |-
          mkdir dist
          cp macos-latest/*.tar.gz macos-latest/*.whl ./dist/
          python3 -m pip install --upgrade twine
          python -m twine upload --username "__token__" --password "${{ secrets.pypi_token }}" dist/*

  ### Build and publish Chocolatey package
  chocolatey-package:
    runs-on: windows-latest
    needs: [build, push-build]
    if: inputs.deploy == true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Windows Artifact
        uses: actions/download-artifact@v4
        with:
          name: windows-latest
          path: dist

      - name: Check if zip file exists
        run: |
          ls -la dist
          if (Test-Path "dist/pieces-cli-win_x86_64-*.zip") {
            Write-Output "Zip file exists"
          } else {
            Write-Output "Zip file does not exist"
          }

      - name: Setup Chocolatey
        uses: chocolatey/setup-chocolatey@v1

      - name: Install Chocolatey Package Builder
        run: choco install chocolatey-package-builder -y

      - name: Get the version
        shell: bash
        id: get_version
        run: echo "VERSION=$(echo $GITHUB_REF | cut -d / -f 3)" >> $GITHUB_OUTPUT

      - name: Get Release Notes
        id: release_notes
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}".TrimStart("v")
          $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/tags/v$version" -Headers @{
            "Accept" = "application/vnd.github.v3+json"
            "Authorization" = "token ${{ secrets.GITHUB_TOKEN }}"
          }
          $releaseNotes = $response.body
          # Escape any special characters that might break the nuspec XML
          $releaseNotes = [System.Security.SecurityElement]::Escape($releaseNotes)
          echo "RELEASE_NOTES=$releaseNotes" >> $env:GITHUB_OUTPUT

      - name: Copy Exe to Package
        run: |
          Copy-Item -Path "dist/pieces-cli-win_x86_64-*.zip" -Destination "choco/tools/pieces-cli.zip" -Force
          Expand-Archive -Path "choco/tools/pieces-cli.zip" -DestinationPath "choco/tools" -Force
          Remove-Item "choco/tools/pieces-cli.zip" -Force

      - name: Copy LICENSE
        run: |
          Copy-Item -Path "LICENSE" -Destination "choco/tools/LICENSE.txt" -Force
          Write-Output "Copied LICENSE to package"

      - name: Update Package Version
        shell: pwsh
        run: |
          cd choco
          $nuspec = Get-Content pieces-cli.nuspec
          $newVersion = "${{ steps.get_version.outputs.VERSION }}".TrimStart("v")
          
          # Update version in nuspec
          $nuspec = $nuspec -replace '<version>.*?</version>', "<version>$newVersion</version>"
          
          # Update release notes with the actual GitHub release notes
          # Should we add the release notes to the nuspec?
          # $releaseNotes = "${{ steps.release_notes.outputs.RELEASE_NOTES }}"
          # $nuspec = $nuspec -replace '<releaseNotes>.*?</releaseNotes>', "<releaseNotes>$releaseNotes</releaseNotes>"
          
          $nuspec | Set-Content pieces-cli.nuspec
          
          Write-Output "Updated nuspec version to $newVersion"

      - name: Build Chocolatey Package
        run: |
          cd choco
          choco pack

      - name: Test Package
        run: |
          choco install pieces-cli -s . -y
          pieces --version
          choco uninstall pieces-cli -y

      - name: Publish to Chocolatey
        env:
          CHOCOLATEY_API_KEY: ${{ secrets.chocolatey_api_key }}
        run: |
          choco apikey --key $env:CHOCOLATEY_API_KEY --source https://push.chocolatey.org/
          choco push pieces-cli.*.nupkg --source https://push.chocolatey.org/ --force

      ### We might remove this setup later after testing!
      - name: Upload Chocolatey Package
        uses: actions/upload-artifact@v4
        with:
          name: chocolatey-package
          path: choco/
          if-no-files-found: error
